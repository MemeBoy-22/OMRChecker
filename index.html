<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Auto OMR Scanner</title>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <style>
    /* (All your styles previously provided: container, header, overlay, buttons, canvas hidden, etc.) */
    /* â€¦ */
    .overlay { position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; z-index:2; }
    .overlay svg { width:100%; height:100%; }
    .alignment-guide { stroke:#00ff00; stroke-width:3; fill:none; stroke-dasharray:10,5; opacity:0.8; }
    .corner-marker { fill:#ff0000; opacity:0.7; }
  </style>
</head>
<body>
  <!-- (Your full markup: container, header, controls, camera-section with overlay, results-section) -->
  <div class="overlay"><svg id="overlaySvg"></svg></div>
  <canvas id="canvas" style="display:none"></canvas>
  <canvas id="proc" style="display:none"></canvas>
  
  <script>
    const video = document.getElementById('video');
    const cvCanvas = document.getElementById('canvas');
    const proc = document.getElementById('proc');
    const overlay = document.getElementById('overlaySvg');
    const ctx = cvCanvas.getContext('2d');
    const pctx = proc.getContext('2d');

    let answerKey=null, mode='answer';
    document.getElementById('setAnswerKey').onclick=()=>{mode='answer';updateModeIndicator();}
    document.getElementById('evaluateMode').onclick=()=>{if(!answerKey)return alert('Set key first');mode='evaluate';updateModeIndicator();}
    function updateModeIndicator(){
      const el=document.getElementById('modeIndicator');
      el.textContent= mode==='answer'?'Answer Key Mode':'Evaluate Mode';
      el.className= 'mode-indicator ' + (mode==='answer'?'mode-answer-key':'mode-evaluate');
    }

    async function startCam(){
      const stream=await navigator.mediaDevices.getUserMedia({video:{facingMode:'environment'}});
      video.srcObject=stream;await video.play();
      cvCanvas.width=video.videoWidth;cvCanvas.height=video.videoHeight;
      proc.width = video.videoWidth;proc.height = video.videoHeight;
      video.onloadedmetadata=updateOverlay;
      requestAnimationFrame(processLoop);
    }
    document.getElementById('startCamera').onclick=startCam;

    function updateOverlay(){
      const w=video.videoWidth, h=video.videoHeight;
      const portrait = h>w;
      const rect = portrait ?
        {x:0.10*w, y:0.10*h, w:0.80*w, h:0.80*h} :
        {x:0.10*w, y:0.10*h, w:0.80*w, h:0.80*h};
      const {x,y,w:rw,h:rh}=rect;
      const c = (i,n,d)=>i + d*(n-1); // for corners
      overlay.innerHTML = `
        <rect class="alignment-guide" x="${x}" y="${y}" width="${rw}" height="${rh}" rx="10"/>
        <circle class="corner-marker" cx="${x}" cy="${y}" r="8"/>
        <circle class="corner-marker" cx="${x+rw}" cy="${y}" r="8"/>
        <circle class="corner-marker" cx="${x+rw}" cy="${y+rh}" r="8"/>
        <circle class="corner-marker" cx="${x}" cy="${y+rh}" r="8"/>
      `;
    }

    let stable=0;
    const STABLE_THRESHOLD=20;
    let lastFrameData=null;

    function processLoop(){
      ctx.drawImage(video,0,0);
      const img = ctx.getImageData(0,0,cvCanvas.width,cvCanvas.height);
      const data = img.data;
      if(!lastFrameData) lastFrameData=new Uint8ClampedArray(data);
      let diff=0;
      for(let i=0;i<data.length;i+=4){
        diff += Math.abs(data[i]-lastFrameData[i]);
      }
      const change = diff / data.length;
      lastFrameData = new Uint8ClampedArray(data);
      if(change<1){ stable++; } else { stable=0; }
      if(stable===STABLE_THRESHOLD){
        stable=0;
        captureAndProcess();
      }
      requestAnimationFrame(processLoop);
    }

    function captureAndProcess(){
      ctx.drawImage(video,0,0);
      const W=cvCanvas.width, H=cvCanvas.height;
      // Grayscale
      const img = ctx.getImageData(0,0,W,H);
      const d=img.data;
      for(let i=0;i<d.length;i+=4){
        const g = 0.2126*d[i]+0.7152*d[i+1]+0.0722*d[i+2];
        d[i]=d[i+1]=d[i+2]=g;
      }
      proc.putImageData(img,0,0);
      // detect border for perspective correct
      const edges = detectBlackBorder(img,W,H);
      if(!edges) return;
      const warp = fourPointWarp(proc, edges, 1000,750);
      analyzeWarp(warp);
    }

    // Tiny edge detection + border: find outermost dark rectangle
    function detectBlackBorder(img,W,H){
      const d=img.data;
      const thresh=40;
      const coords=[];
      for(let y=0;y<H;y+=10){
        for(let x=0;x<W;x+=10){
          const i=(y*W+x)*4;
          if(d[i]<thresh){
            coords.push({x,y});
          }
        }
      }
      if(coords.length<100)return null;
      // bounding box
      const xs=coords.map(p=>p.x), ys=coords.map(p=>p.y);
      const minX=Math.min(...xs), maxX=Math.max(...xs);
      const minY=Math.min(...ys), maxY=Math.max(...ys);
      return [{x:minX,y:minY},{x:maxX,y:minY},{x:maxX,y:maxY},{x:minX,y:maxY}];
    }

    function fourPointWarp(canvasIn,pts,W2,H2){
      // use simple library-free warp: assume bounding rect
      const temp=document.createElement('canvas');
      temp.width=W2; temp.height=H2;
      const ictx=temp.getContext('2d');
      ictx.drawImage(canvasIn, pts[0].x,pts[0].y, pts[2].x-pts[0].x, pts[2].y-pts[0].y, 0,0,W2,H2);
      return ictx.getImageData(0,0,W2,H2);
    }

    function analyzeWarp(warp){
      const W=warp.width, H=warp.height;
      // ID region: right side
      const idCols = 4, idRows=10;
      const colW = 0.15*W/idCols, rowH=0.8*H/idRows;
      const idX0=0.8*W, idY0=0.1*H;
      const id = [];
      for(let c=0;c<idCols;c++){
        let best=-1, bestVal=0;
        for(let r=0;r<idRows;r++){
          const val = avgGrayRegion(warp,
            idX0 + c*colW, idY0 + r*rowH, colW, rowH);
          if(val>bestVal){ bestVal=val; best=r; }
        }
        id.push(best);
      }
      // Answers region: left area
      const q=20, opts=5;
      const aW=0.6*W, aH=0.8*H;
      const ax0=0.1*W, ay0=0.1*H;
      const rowH2 = aH/q, cellW= aW/opts;
      const answers=[];
      for(let i=0;i<q;i++){
        let sel=null, mval=0;
        for(let o=0;o<opts;o++){
          const val = avgGrayRegion(warp,
            ax0 + o*cellW, ay0 + i*rowH2, cellW, rowH2);
          if(val>mval){ mval=val; sel=o; }
        }
        answers.push(sel);
      }
      if(mode==='answer'){
        answerKey = answers;
        alert('Answer key saved.');
      } else {
        let score=0;
        answers.forEach((a,i)=>{ if(a===answerKey[i])score++; });
        document.getElementById('scoreNumber').textContent = `${score} / 20`;
        document.getElementById('resultsSection').style.display = 'block';
      }
    }

    function avgGrayRegion(img, x0,y0,w,h){
      const W=img.width, d=img.data;
      let sum=0,c=0;
      for(let y=y0+5;y<y0+h-5;y+=3){
        for(let x=x0+5;x<x0+w-5;x+=3){
          const i=(Math.floor(y)*W+Math.floor(x))*4;
          sum += 255 - d[i];
          c++;
        }
      }
      return sum/c;
    }
  </script>
</body>
</html>

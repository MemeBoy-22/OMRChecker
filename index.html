<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OMR Sheet Scanner and Grader</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #2c3e50, #3498db);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .main-content {
            padding: 40px;
        }

        .section {
            margin-bottom: 40px;
            padding: 30px;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            background: #f8f9fa;
        }

        .section h2 {
            color: #2c3e50;
            margin-bottom: 20px;
            font-size: 1.5rem;
        }

        .upload-area {
            border: 3px dashed #3498db;
            border-radius: 10px;
            padding: 40px;
            text-align: center;
            background: white;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .upload-area:hover {
            border-color: #2980b9;
            background: #f0f8ff;
        }

        .upload-area.dragover {
            border-color: #27ae60;
            background: #f0fff0;
        }

        .upload-button {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            font-size: 1.1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 10px;
        }

        .upload-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(52, 152, 219, 0.4);
        }

        .upload-button:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
            transform: none;
        }

        .view-button {
            background: linear-gradient(135deg, #27ae60, #219a52);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 8px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 10px;
        }

        .view-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(39, 174, 96, 0.4);
        }

        .status {
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            font-weight: 500;
        }

        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .status.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .preview {
            margin: 20px 0;
            text-align: center;
        }

        .preview img {
            max-width: 100%;
            max-height: 400px;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .answer-key-display {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            border: 1px solid #ddd;
        }

        .answer-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .answer-item {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 5px;
            text-align: center;
            border: 1px solid #e9ecef;
        }

        .answer-item strong {
            color: #2c3e50;
        }

        .results {
            background: white;
            padding: 25px;
            border-radius: 8px;
            margin: 20px 0;
            border: 1px solid #ddd;
        }

        .result-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #e9ecef;
        }

        .student-id {
            font-size: 1.2rem;
            font-weight: bold;
            color: #2c3e50;
        }

        .grade {
            font-size: 1.5rem;
            font-weight: bold;
            padding: 10px 20px;
            border-radius: 8px;
        }

        .grade.excellent {
            background: #d4edda;
            color: #155724;
        }

        .grade.good {
            background: #fff3cd;
            color: #856404;
        }

        .grade.needs-improvement {
            background: #f8d7da;
            color: #721c24;
        }

        .processing {
            text-align: center;
            padding: 20px;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .hidden {
            display: none;
        }

        #debugCanvas {
            margin: 20px 0;
            border: 1px solid #ddd;
            max-width: 100%;
        }

        .debug-info {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            font-family: monospace;
            font-size: 0.9rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1>OMR Sheet Scanner & Grader</h1>
            <p>Upload answer key and student sheets for automatic grading</p>
        </header>

        <div class="main-content">
            <!-- Answer Key Section -->
            <div class="section">
                <h2>üìã Step 1: Upload Answer Key</h2>
                <div class="upload-area" id="answerKeyUpload">
                    <p>Click here or drag and drop your answer key OMR sheet</p>
                    <button class="upload-button" onclick="document.getElementById('answerKeyFile').click()">
                        Choose Answer Key File
                    </button>
                    <input type="file" id="answerKeyFile" accept="image/*" style="display: none;">
                </div>
                
                <div id="answerKeyStatus"></div>
                <div id="answerKeyPreview" class="preview hidden"></div>
                <canvas id="debugCanvas" class="hidden"></canvas>
                <div id="debugInfo" class="debug-info hidden"></div>
                <button id="viewAnswerKeyBtn" class="view-button hidden" onclick="toggleAnswerKeyDisplay()">
                    View Answer Key
                </button>
                <div id="answerKeyDisplay" class="answer-key-display hidden"></div>
            </div>

            <!-- Student Sheet Section -->
            <div class="section">
                <h2>üìù Step 2: Upload Student Answer Sheet</h2>
                <div class="upload-area" id="studentSheetUpload">
                    <p>Click here or drag and drop student OMR sheet</p>
                    <button class="upload-button" id="studentUploadBtn" onclick="document.getElementById('studentSheetFile').click()" disabled>
                        Choose Student Sheet File
                    </button>
                    <input type="file" id="studentSheetFile" accept="image/*" style="display: none;">
                </div>
                
                <div id="studentSheetStatus"></div>
                <div id="studentSheetPreview" class="preview hidden"></div>
                <div id="gradingResults" class="results hidden"></div>
            </div>
        </div>
    </div>

    <canvas id="canvas" style="display: none;"></canvas>

    <script>
        let answerKey = null;
        let answerKeyDetected = false;

        // Initialize event listeners
        document.getElementById('answerKeyFile').addEventListener('change', handleAnswerKeyUpload);
        document.getElementById('studentSheetFile').addEventListener('change', handleStudentSheetUpload);

        // Drag and drop functionality
        setupDragAndDrop('answerKeyUpload', 'answerKeyFile');
        setupDragAndDrop('studentSheetUpload', 'studentSheetFile');

        function setupDragAndDrop(uploadAreaId, fileInputId) {
            const uploadArea = document.getElementById(uploadAreaId);
            const fileInput = document.getElementById(fileInputId);

            uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadArea.classList.add('dragover');
            });

            uploadArea.addEventListener('dragleave', () => {
                uploadArea.classList.remove('dragover');
            });

            uploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadArea.classList.remove('dragover');
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    fileInput.files = files;
                    fileInput.dispatchEvent(new Event('change'));
                }
            });
        }

        function showStatus(elementId, message, type) {
            const statusElement = document.getElementById(elementId);
            statusElement.innerHTML = `<div class="status ${type}">${message}</div>`;
        }

        function showProcessing(elementId) {
            const statusElement = document.getElementById(elementId);
            statusElement.innerHTML = `
                <div class="processing">
                    <div class="spinner"></div>
                    <p>Processing OMR sheet...</p>
                </div>
            `;
        }

        async function handleAnswerKeyUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            showProcessing('answerKeyStatus');
            
            try {
                const imageUrl = URL.createObjectURL(file);
                
                // Show preview
                const preview = document.getElementById('answerKeyPreview');
                preview.innerHTML = `<img src="${imageUrl}" alt="Answer Key Preview">`;
                preview.classList.remove('hidden');

                // Process the image
                const detectedAnswers = await processOMRSheet(imageUrl, true);
                
                if (detectedAnswers && detectedAnswers.answers) {
                    answerKey = detectedAnswers.answers;
                    answerKeyDetected = true;
                    
                    showStatus('answerKeyStatus', '‚úÖ Answer key detected and processed successfully!', 'success');
                    
                    // Show view answer key button
                    document.getElementById('viewAnswerKeyBtn').classList.remove('hidden');
                    
                    // Enable student upload
                    document.getElementById('studentUploadBtn').disabled = false;
                    
                } else {
                    showStatus('answerKeyStatus', '‚ùå Error: No answer key detected. Please ensure the image contains a valid OMR sheet.', 'error');
                    answerKeyDetected = false;
                }
                
            } catch (error) {
                showStatus('answerKeyStatus', '‚ùå Error processing image: ' + error.message, 'error');
                answerKeyDetected = false;
            }
        }

        async function handleStudentSheetUpload(event) {
            const file = event.target.files[0];
            if (!file || !answerKeyDetected) return;

            showProcessing('studentSheetStatus');
            
            try {
                const imageUrl = URL.createObjectURL(file);
                
                // Show preview
                const preview = document.getElementById('studentSheetPreview');
                preview.innerHTML = `<img src="${imageUrl}" alt="Student Sheet Preview">`;
                preview.classList.remove('hidden');

                // Process the image
                const detectedData = await processOMRSheet(imageUrl, false);
                
                if (detectedData && detectedData.answers && detectedData.studentId) {
                    const grade = calculateGrade(detectedData.answers, answerKey);
                    showGradingResults(detectedData.studentId, grade, detectedData.answers);
                    showStatus('studentSheetStatus', '‚úÖ Student sheet processed successfully!', 'success');
                } else {
                    showStatus('studentSheetStatus', '‚ùå Error: Could not detect student answers or ID from the OMR sheet.', 'error');
                }
                
            } catch (error) {
                showStatus('studentSheetStatus', '‚ùå Error processing student sheet: ' + error.message, 'error');
            }
        }

        async function processOMRSheet(imageUrl, isAnswerKey) {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.getElementById('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    // Set canvas size
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0);
                    
                    try {
                        const result = detectOMRBubbles(ctx, canvas.width, canvas.height, isAnswerKey);
                        resolve(result);
                    } catch (error) {
                        console.error('Error detecting bubbles:', error);
                        resolve(null);
                    }
                };
                img.onerror = () => resolve(null);
                img.src = imageUrl;
            });
        }

        function detectOMRBubbles(ctx, width, height, isAnswerKey) {
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;
            
            // Convert to grayscale and apply threshold
            const grayData = new Uint8Array(width * height);
            for (let i = 0; i < data.length; i += 4) {
                const gray = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
                grayData[i / 4] = gray < 128 ? 0 : 255; // Binary threshold
            }

            // Define approximate regions for bubble detection based on OMR layout
            const bubbleRegions = detectBubbleRegions(grayData, width, height);
            
            if (!bubbleRegions) {
                return null;
            }

            const answers = {};
            const studentId = isAnswerKey ? null : detectStudentId(bubbleRegions.idRegion, grayData, width, height);

            // Process answer bubbles
            // Questions 1-10 are in the left column (A-E options)
            for (let q = 1; q <= 10; q++) {
                const questionBubbles = getQuestionBubbles(bubbleRegions.leftColumn, q - 1, grayData, width, height);
                answers[q] = getMarkedOption(questionBubbles);
            }

            // Questions 11-20 are in the right column (A-E options)
            for (let q = 11; q <= 20; q++) {
                const questionBubbles = getQuestionBubbles(bubbleRegions.rightColumn, q - 11, grayData, width, height);
                answers[q] = getMarkedOption(questionBubbles);
            }

            // Debug visualization
            if (isAnswerKey) {
                visualizeDetection(ctx, bubbleRegions, answers, width, height);
            }

            return {
                answers: answers,
                studentId: studentId
            };
        }

        function detectBubbleRegions(grayData, width, height) {
            // Detect the red border guidelines first for proper alignment
            const redBorder = detectRedBorder(grayData, width, height);
            
            if (!redBorder) {
                // Fallback to manual regions based on the provided image layout
                return getManualBubbleRegions(width, height);
            }
            
            // Use detected border to calculate precise regions
            return calculateRegionsFromBorder(redBorder, width, height);
        }

        function detectRedBorder(grayData, width, height) {
            // Convert grayscale back to color data for red detection
            // This is a simplified version - in practice you'd work with the original color data
            // For now, we'll use the manual approach
            return null;
        }

        function getManualBubbleRegions(width, height) {
            // Based on the marked image analysis:
            // - Left answer column starts around 8% from left, width ~35%
            // - Right answer column starts around 45% from left, width ~35% 
            // - ID section starts around 82% from left, width ~15%
            // - Top margin around 12%, usable height ~75%
            
            const topMargin = Math.floor(height * 0.12);
            const usableHeight = Math.floor(height * 0.75);
            const questionHeight = Math.floor(usableHeight / 10);
            
            return {
                leftColumn: {
                    x: Math.floor(width * 0.08),
                    y: topMargin,
                    width: Math.floor(width * 0.35),
                    height: usableHeight
                },
                rightColumn: {
                    x: Math.floor(width * 0.45),
                    y: topMargin, 
                    width: Math.floor(width * 0.35),
                    height: usableHeight
                },
                idRegion: {
                    x: Math.floor(width * 0.82),
                    y: topMargin,
                    width: Math.floor(width * 0.15),
                    height: usableHeight
                },
                questionHeight: questionHeight
            };
        }

        function calculateRegionsFromBorder(border, width, height) {
            // This would be used when red border detection works
            return getManualBubbleRegions(width, height);
        }

        function getQuestionBubbles(columnRegion, questionIndex, grayData, width, height) {
            const questionY = columnRegion.y + (questionIndex * columnRegion.height / 10);
            const questionHeight = columnRegion.height / 10;
            
            // Adjusted bubble spacing based on the marked image
            const bubbleSpacing = columnRegion.width / 5.5; // Slightly tighter spacing
            const bubbleStartX = columnRegion.x + (bubbleSpacing * 0.3); // Start offset
            
            const bubbles = [];
            const options = ['A', 'B', 'C', 'D', 'E'];
            
            for (let i = 0; i < 5; i++) {
                const bubbleX = bubbleStartX + (i * bubbleSpacing);
                const bubbleSize = Math.min(bubbleSpacing * 0.6, questionHeight * 0.6);
                
                const bubbleRegion = {
                    x: Math.floor(bubbleX),
                    y: Math.floor(questionY + questionHeight * 0.25),
                    width: Math.floor(bubbleSize),
                    height: Math.floor(bubbleSize),
                    option: options[i]
                };
                
                const fillPercentage = calculateBubbleFill(bubbleRegion, grayData, width, height);
                bubbles.push({
                    option: options[i],
                    fillPercentage: fillPercentage
                });
            }
            
            return bubbles;
        }

        function calculateBubbleFill(bubbleRegion, grayData, width, height) {
            let totalPixels = 0;
            let filledPixels = 0;
            
            for (let y = bubbleRegion.y; y < bubbleRegion.y + bubbleRegion.height && y < height; y++) {
                for (let x = bubbleRegion.x; x < bubbleRegion.x + bubbleRegion.width && x < width; x++) {
                    const index = y * width + x;
                    if (index < grayData.length) {
                        totalPixels++;
                        if (grayData[index] === 0) { // Black pixel (filled)
                            filledPixels++;
                        }
                    }
                }
            }
            
            return totalPixels > 0 ? (filledPixels / totalPixels) * 100 : 0;
        }

        function getMarkedOption(bubbles) {
            // Find the bubble with highest fill percentage
            let maxFill = 0;
            let markedOption = 'A'; // Default
            
            bubbles.forEach(bubble => {
                if (bubble.fillPercentage > maxFill && bubble.fillPercentage > 25) { // Increased threshold for better accuracy
                    maxFill = bubble.fillPercentage;
                    markedOption = bubble.option;
                }
            });
            
            // If no bubble has sufficient fill, return the one with highest fill anyway
            if (maxFill < 25) {
                let highestFill = 0;
                bubbles.forEach(bubble => {
                    if (bubble.fillPercentage > highestFill) {
                        highestFill = bubble.fillPercentage;
                        markedOption = bubble.option;
                    }
                });
            }
            
            return markedOption;
        }

        function detectStudentId(idRegion, grayData, width, height) {
            // Based on the blue-marked ID region in your image
            // 4 columns for digits, 10 rows for numbers 0-9
            const digitWidth = idRegion.width / 4;
            const digitHeight = idRegion.height / 10;
            
            let studentId = '';
            
            for (let digit = 0; digit < 4; digit++) {
                let maxFill = 0;
                let selectedDigit = '0';
                
                for (let num = 0; num < 10; num++) {
                    // More precise bubble positioning
                    const bubbleX = Math.floor(idRegion.x + digit * digitWidth + digitWidth * 0.25);
                    const bubbleY = Math.floor(idRegion.y + num * digitHeight + digitHeight * 0.25);
                    const bubbleSize = Math.min(digitWidth * 0.5, digitHeight * 0.5);
                    
                    const bubbleRegion = {
                        x: bubbleX,
                        y: bubbleY,
                        width: Math.floor(bubbleSize),
                        height: Math.floor(bubbleSize)
                    };
                    
                    const fillPercentage = calculateBubbleFill(bubbleRegion, grayData, width, height);
                    
                    if (fillPercentage > maxFill && fillPercentage > 20) { // Slightly higher threshold
                        maxFill = fillPercentage;
                        selectedDigit = num.toString();
                    }
                }
                
                studentId += selectedDigit;
            }
            
            return studentId;
        }

        function visualizeDetection(ctx, bubbleRegions, answers, width, height) {
            // Create debug canvas
            const debugCanvas = document.getElementById('debugCanvas');
            const debugCtx = debugCanvas.getContext('2d');
            debugCanvas.width = width;
            debugCanvas.height = height;
            debugCanvas.classList.remove('hidden');
            
            // Copy original image
            debugCtx.drawImage(ctx.canvas, 0, 0);
            
            // Draw detection regions with different colors
            debugCtx.lineWidth = 3;
            
            // Left column (green)
            debugCtx.strokeStyle = 'lime';
            debugCtx.strokeRect(bubbleRegions.leftColumn.x, bubbleRegions.leftColumn.y, 
                               bubbleRegions.leftColumn.width, bubbleRegions.leftColumn.height);
            
            // Right column (green)
            debugCtx.strokeStyle = 'lime';
            debugCtx.strokeRect(bubbleRegions.rightColumn.x, bubbleRegions.rightColumn.y, 
                               bubbleRegions.rightColumn.width, bubbleRegions.rightColumn.height);
            
            // ID region (blue)
            debugCtx.strokeStyle = 'blue';
            debugCtx.strokeRect(bubbleRegions.idRegion.x, bubbleRegions.idRegion.y, 
                               bubbleRegions.idRegion.width, bubbleRegions.idRegion.height);
            
            // Draw individual bubble detection areas
            debugCtx.strokeStyle = 'orange';
            debugCtx.lineWidth = 1;
            
            // Visualize bubble positions for first few questions
            for (let q = 0; q < 3; q++) {
                const questionY = bubbleRegions.leftColumn.y + (q * bubbleRegions.leftColumn.height / 10);
                const questionHeight = bubbleRegions.leftColumn.height / 10;
                const bubbleSpacing = bubbleRegions.leftColumn.width / 5.5;
                const bubbleStartX = bubbleRegions.leftColumn.x + (bubbleSpacing * 0.3);
                
                for (let i = 0; i < 5; i++) {
                    const bubbleX = bubbleStartX + (i * bubbleSpacing);
                    const bubbleSize = Math.min(bubbleSpacing * 0.6, questionHeight * 0.6);
                    
                    debugCtx.strokeRect(
                        Math.floor(bubbleX),
                        Math.floor(questionY + questionHeight * 0.25),
                        Math.floor(bubbleSize),
                        Math.floor(bubbleSize)
                    );
                }
            }
            
            // Show debug info
            const debugInfo = document.getElementById('debugInfo');
            debugInfo.innerHTML = `
                <strong>Detection Results (Aligned):</strong><br>
                Detected Answers: ${JSON.stringify(answers)}<br>
                Image Dimensions: ${width}x${height}<br>
                Left Column: x=${bubbleRegions.leftColumn.x}, y=${bubbleRegions.leftColumn.y}, w=${bubbleRegions.leftColumn.width}, h=${bubbleRegions.leftColumn.height}<br>
                Right Column: x=${bubbleRegions.rightColumn.x}, y=${bubbleRegions.rightColumn.y}, w=${bubbleRegions.rightColumn.width}, h=${bubbleRegions.rightColumn.height}<br>
                ID Region: x=${bubbleRegions.idRegion.x}, y=${bubbleRegions.idRegion.y}, w=${bubbleRegions.idRegion.width}, h=${bubbleRegions.idRegion.height}<br>
                <strong>Green lines:</strong> Answer regions | <strong>Blue lines:</strong> ID region | <strong>Orange boxes:</strong> Individual bubbles (first 3 questions)
            `;
            debugInfo.classList.remove('hidden');
        }

        function calculateGrade(studentAnswers, correctAnswers) {
            let correct = 0;
            const total = 20;
            
            for (let i = 1; i <= total; i++) {
                if (studentAnswers[i] === correctAnswers[i]) {
                    correct++;
                }
            }
            
            return {
                correct: correct,
                total: total,
                percentage: Math.round((correct / total) * 100)
            };
        }

        function showGradingResults(studentId, grade, studentAnswers) {
            const resultsDiv = document.getElementById('gradingResults');
            
            let gradeClass = 'needs-improvement';
            if (grade.percentage >= 80) gradeClass = 'excellent';
            else if (grade.percentage >= 60) gradeClass = 'good';
            
            let detailedResults = '';
            for (let i = 1; i <= 20; i++) {
                const isCorrect = studentAnswers[i] === answerKey[i];
                detailedResults += `
                    <div class="answer-item" style="background: ${isCorrect ? '#d4edda' : '#f8d7da'};">
                        <strong>Q${i}:</strong> ${studentAnswers[i]} 
                        ${isCorrect ? '‚úÖ' : `‚ùå (Correct: ${answerKey[i]})`}
                    </div>
                `;
            }
            
            resultsDiv.innerHTML = `
                <div class="result-header">
                    <div class="student-id">Student ID: ${studentId}</div>
                    <div class="grade ${gradeClass}">${grade.correct}/${grade.total} (${grade.percentage}%)</div>
                </div>
                <h3>Detailed Results:</h3>
                <div class="answer-grid">
                    ${detailedResults}
                </div>
            `;
            
            resultsDiv.classList.remove('hidden');
        }

        function toggleAnswerKeyDisplay() {
            const display = document.getElementById('answerKeyDisplay');
            const button = document.getElementById('viewAnswerKeyBtn');
            
            if (display.classList.contains('hidden')) {
                let answerKeyHTML = '<h3>Answer Key:</h3><div class="answer-grid">';
                
                for (let i = 1; i <= 20; i++) {
                    answerKeyHTML += `
                        <div class="answer-item">
                            <strong>Question ${i}:</strong> ${answerKey[i]}
                        </div>
                    `;
                }
                
                answerKeyHTML += '</div>';
                display.innerHTML = answerKeyHTML;
                display.classList.remove('hidden');
                button.textContent = 'Hide Answer Key';
            } else {
                display.classList.add('hidden');
                button.textContent = 'View Answer Key';
            }
        }
    </script>
</body>
</html>
